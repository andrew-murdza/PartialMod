package net.amurdza.examplemod.block;import net.minecraft.core.BlockPos;import net.minecraft.core.Direction;import net.minecraft.server.level.ServerLevel;import net.minecraft.util.RandomSource;import net.minecraft.world.level.BlockGetter;import net.minecraft.world.level.Level;import net.minecraft.world.level.LevelAccessor;import net.minecraft.world.level.LevelReader;import net.minecraft.world.level.block.*;import net.minecraft.world.level.block.state.BlockState;import net.minecraft.world.level.block.state.StateDefinition;import net.minecraft.world.level.block.state.properties.BlockStateProperties;import net.minecraft.world.level.block.state.properties.BooleanProperty;import net.minecraft.world.level.block.state.properties.NoteBlockInstrument;import net.minecraft.world.level.gameevent.GameEvent;import net.minecraft.world.level.material.FluidState;import net.minecraft.world.level.material.Fluids;import net.minecraft.world.level.material.PushReaction;//public class GrapeVineNew extends Block implements SimpleWaterloggedBlock, BonemealableBlock {//    public static final DirectionProperty FACING= HorizontalDirectionalBlock.FACING;//    public static final BooleanProperty WATERLOGGED= BlockStateProperties.WATERLOGGED;//    public GrapeVineNew() {//        super(BlockBehaviour.Properties.of().instrument(NoteBlockInstrument.BASEDRUM).sound(SoundType.VINE).strength(1.0F, 10.0F).noCollission().noOcclusion().pushReaction(PushReaction.DESTROY).isRedstoneConductor((bs, br, bp) -> false));//        this.registerDefaultState(this.stateDefinition.any().setValue(FACING, Direction.NORTH).setValue(WATERLOGGED, false));//    }//    //accounts for waterlogged//    public boolean propagatesSkylightDown(BlockState state, BlockGetter reader, BlockPos pos) {//        return state.getFluidState().isEmpty();//    }//    //not sure what this is for//    public int getLightBlock(BlockState state, BlockGetter worldIn, BlockPos pos) {//        return 0;//    }////    //only needed if has collision but this block doesn't seem to//    public VoxelShape getVisualShape(BlockState state, BlockGetter world, BlockPos pos, CollisionContext context) {//        return Shapes.empty();//    }//    public VoxelShape getShape(BlockState state, BlockGetter world, BlockPos pos, CollisionContext context) {//        VoxelShape var10000;//        switch (state.getValue(FACING)) {//            case NORTH -> var10000 = box(0.0, 0.0, 15.4, 16.0, 16.0, 15.8);//            case EAST -> var10000 = box(0.2, 0.0, 0.0, 0.6, 16.0, 16.0);//            case WEST -> var10000 = box(15.4, 0.0, 0.0, 15.8, 16.0, 16.0);//            default -> var10000 = box(0.0, 0.0, 0.2, 16.0, 16.0, 0.6);//        }//        return var10000;//    }//    //eventually want to add another property//    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {//        builder.add(FACING, WATERLOGGED);//    }//    //eventually want to add y directions//    public BlockState getStateForPlacement(BlockPlaceContext context) {//        boolean flag = context.getLevel().getFluidState(context.getClickedPos()).getType() == Fluids.WATER;//        Direction facingDir=context.getClickedFace();//        Direction direction=facingDir.getAxis() == Direction.Axis.Y?Direction.NORTH:facingDir;//        return defaultBlockState().setValue(FACING, direction).setValue(WATERLOGGED, flag);//    }//    public BlockState rotate(BlockState state, Rotation rot) {//        return state.setValue(FACING, rot.rotate(state.getValue(FACING)));//    }//    public BlockState mirror(BlockState state, Mirror mirrorIn) {//        return state.rotate(mirrorIn.getRotation(state.getValue(FACING)));//    }//    public FluidState getFluidState(BlockState state) {//        return state.getValue(WATERLOGGED) ? Fluids.WATER.getSource(false) : super.getFluidState(state);//    }//    public BlockState updateShape(BlockState state, Direction facing, BlockState facingState, LevelAccessor world, BlockPos currentPos, BlockPos facingPos) {//        if (state.getValue(WATERLOGGED)) {//            world.scheduleTick(currentPos, Fluids.WATER, Fluids.WATER.getTickDelay(world));//        }//        return !state.canSurvive(world, currentPos) ? Blocks.AIR.defaultBlockState() : super.updateShape(state, facing, facingState, world, currentPos, facingPos);//    }////////    public int getFlammability(BlockState state, BlockGetter world, BlockPos pos, Direction face) {////        return 10;////    }////    public int getFireSpreadSpeed(BlockState state, BlockGetter world, BlockPos pos, Direction face) {////        return 10;////    }////////    //probably can remove this////    public ItemStack getCloneItemStack(BlockState state, HitResult target, BlockGetter world, BlockPos pos, Player player) {////        return new ItemStack(ForestModBlocks.GRAPE_VINE_0.get());////    }////    public boolean isLadder(BlockState state, LevelReader world, BlockPos pos, LivingEntity entity) {//        return true;//    }////    public boolean isValidBonemealTarget(LevelReader worldIn, BlockPos pos, BlockState blockstate, boolean clientSide) {//        return true;//    }//    public boolean isBonemealSuccess(Level world, RandomSource random, BlockPos pos, BlockState blockstate) {//        return true;//    }//    public void performBonemeal(ServerLevel world, RandomSource random, BlockPos pos, BlockState blockstate) {//        BlockState state=ForestModBlocks.GRAPE_VINE_1.get().defaultBlockState();//        state=state.setValue(WATERLOGGED,blockstate.getValue(WATERLOGGED));//        state=state.setValue(FACING,blockstate.getValue(FACING));//        world.setBlockAndUpdate(pos,state);//    }public class GrapeVineNew extends MultifaceBlock implements SimpleWaterloggedBlock, BonemealableBlock {    private final MultifaceSpreader spreader = new MultifaceSpreader(this);    public static final BooleanProperty WATERLOGGED= BlockStateProperties.WATERLOGGED;    public static final BooleanProperty BERRIES= BlockStateProperties.BERRIES;    public GrapeVineNew() {        super(Properties.of().instrument(NoteBlockInstrument.BASEDRUM).sound(SoundType.VINE).strength(1.0F, 10.0F).noCollission().noOcclusion().pushReaction(PushReaction.DESTROY).isRedstoneConductor((bs, br, bp) -> false));        this.registerDefaultState(this.defaultBlockState().setValue(WATERLOGGED, false).setValue(BERRIES, false));    }    public boolean propagatesSkylightDown(BlockState state, BlockGetter reader, BlockPos pos) {        return state.getFluidState().isEmpty();    }    //not sure what this is for    public int getLightBlock(BlockState state, BlockGetter worldIn, BlockPos pos) {        return 0;    }    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> pBuilder) {        super.createBlockStateDefinition(pBuilder);        pBuilder.add(WATERLOGGED).add(BERRIES);    }    public FluidState getFluidState(BlockState state) {        return state.getValue(WATERLOGGED) ? Fluids.WATER.getSource(false) : super.getFluidState(state);    }    public BlockState updateShape(BlockState pState, Direction pDirection, BlockState pNeighborState, LevelAccessor pLevel, BlockPos pPos, BlockPos pNeighborPos) {        if (pState.getValue(WATERLOGGED)) {            pLevel.scheduleTick(pPos, Fluids.WATER, Fluids.WATER.getTickDelay(pLevel));        }        return super.updateShape(pState, pDirection, pNeighborState, pLevel, pPos, pNeighborPos);    }    public boolean isValidBonemealTarget(LevelReader worldIn, BlockPos pos, BlockState blockstate, boolean clientSide) {        return !blockstate.getValue(BERRIES);    }    public boolean isBonemealSuccess(Level world, RandomSource random, BlockPos pos, BlockState blockstate) {        return true;    }    public void performBonemeal(ServerLevel world, RandomSource random, BlockPos pos, BlockState blockstate) {        world.setBlockAndUpdate(pos,blockstate.setValue(BERRIES,true));    }    public boolean isRandomlyTicking(BlockState pState) {        return !pState.getValue(BERRIES);    }    public MultifaceSpreader getSpreader() {        return this.spreader;    }    public void randomTick(BlockState pState, ServerLevel pLevel, BlockPos pPos, RandomSource pRandom) {        if (net.minecraftforge.common.ForgeHooks.onCropsGrowPre(pLevel, pPos, pState, pRandom.nextInt(1) == 0)) {//pLevel.getRawBrightness(pPos.above(), 0) >= 9 &&            BlockState blockstate = pState.setValue(BERRIES,true);            pLevel.setBlock(pPos, blockstate, 2);            pLevel.gameEvent(GameEvent.BLOCK_CHANGE, pPos, GameEvent.Context.of(blockstate));            net.minecraftforge.common.ForgeHooks.onCropsGrowPost(pLevel, pPos, pState);        }    }}